<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>metodos</title>
</head>

<body bgcolor="#99CCFF">

<p style="line-height: 100%" align="center"><font size="4"><b>METODOS</b></font><font size="4"><b>
NUMERICOS</b></font></p>
<table border="1" width="745">
  <tr>
    <td width="735"><font color="#000000">UNI-FIEE </font><b><font color="#008000">30
      Nov 1999</font></b></td>
  </tr>
  <tr>
    <td width="735"><font color="#000000">programado por: </font><b><font color="#800000">JOSE
      LUIS DE LA CRUZ LAZARO&nbsp;</font></b></td>
  </tr>
  <tr>
    <td width="735">correos: <a href="mailto:jcruz@ec-red.com">jcruz@ec-red.com</a>
      <font color="#000000"><a href="mailto:ramondc@hotmail.com">ramondc@hotmail.com</a></font></td>
  </tr>
  <tr>
    <td width="735"><font color="#000000">Pagina Web( <b>El Mundo del Caos</b>
      ): <a href="http://www.geocities.com/joseluisdl">http://www.geocities.com/joseluisdl</a></font></td>
  </tr>
  <tr>
    <td width="735">ICQ: <b><font color="#FF0000">46906401</font></b></td>
  </tr>
</table>
<p style="line-height: 100%"><font face="Arial" size="2">Estos son programas que
utilizan métodos numéricos para resolver sistemas de ecuaciones, ecuaciones
diferenciales, métodos de integración, raíces de funciones en 1 variable (
f(x)=0 ), raíces de funciones en 2 variables( f(x,y)=0; g(x,y)=0 ) por
diferentes métodos de solución, y todo esto utilizando un práctico Menú
virtual en modo texto... </font></p>
<p style="line-height: 100%"><font face="Arial" size="3">Todos los métodos
mencionados en este archivo vienen adjuntos con los fuentes hechos en<font color="#FF9900">
</font><b><font color="#FF8000">lenguaje C</font></b>.</font></p>
<p style="line-height: 100%"><font face="Arial" size="3">Principalmente se
detallaran 2 grupos de métodos numéricos:</font></p>
<ul>
  <li>
    <p style="line-height: 100%"><font face="Arial" size="2"><b><a href="#METODOS PARA CALCULAR LAS RAICES DE UNA FUNCION: f(x)=0">METODOS
    PARA CALCULAR LAS RAICES DE UNA FUNCION: f(x)=0</a></b></font></li>
  <li>
    <p style="line-height: 100%"><b><font face="Arial" size="2"><a href="#Ax=B ( MATRICES )">METODOS
    NUMERICOS PARA SOLUCIONAR SISTEMAS DE ECUACIONES Ax=B ( MATRICES )</a></font></b></li>
</ul>
<p style="line-height: 100%">&nbsp;</p>
<div align="left">
  <pre><b><font color="#000000" face="Arial" size="3"><a name="METODOS PARA CALCULAR LAS RAICES DE UNA FUNCION: f(x)=0">METODOS</a></font></b><font face="Arial" size="3"><a name="METODOS PARA CALCULAR LAS RAICES DE UNA FUNCION: f(x)=0"><b></b><font color="#000000"><b> PARA CALCULAR LAS RAICES DE UNA FUNCION: f(x)=0</b></font></a></font></pre>
</div>
<div align="left">
  <blockquote>
    <pre><font face="Arial" size="3">   <a href="#//Metodo de la bisecci¢n">Método de Bisección</a>
   <a href="#//Metodo de la falsa posici¢n">Método de la Falsa Posición</a>
   <a href="#//Metodo de la secante">Método de la Secante</a>
   <a href="#//Metodo de Newton-Raphson">Método de Newton-Raphson</a>
   <a href="#//Metódo del punto fijo">Método del Punto Fijo</a>
   </font></pre>
  </blockquote>
</div>
<pre><font face="Arial" size="3">Para este ejemplo se solucionará la funcion <b><font color="#FF0000">f(x)=xtan(x)-x^2-0.168=0</font></b></font></pre>
<div align="center">
  <center>
  <pre><b><font face="Arial" size="3" color="#EA7500">Funciones Nesesarias para ingreso de datos de f(x) </font></b></pre>
  </center>
</div>
<pre><font color="#008000">//definicion de la funcion f(x)</font><font color="#000000">
</font><font color="#0000FF">double f( double x)</font><font color="#000000">
{
 //f(x)=xtan(x)-x^2-0.168=0
 return x*tan(x)-x*x-0.168;
}</font></pre>
<pre><font color="#008000">//definicion de la funcion g(x)
//para obtener g(x) se despeja convenientemente f(x)
//de forma que quede x=g(x) donde g'(x)&lt;1 ( derivada de g(x) &lt;1 )
//esta funcion se utiliza en el Método del punto fijo</font><font color="#000000">
</font><font color="#0000FF">double g( double x)</font><font color="#000000">
{
 //x=g(x)=(x^2+0.168)/tan(x);
 return (x*x+0.168)/tan(x);
}</font></pre>
<pre><font color="#0000FF">double fderivada(double x)</font><font color="#000000">
{
 /*
 derivamos por definicion
  lim  ( f(x+h)-f(x) )/h
 h-&gt;0
 */
 double h=1e-6;
 return (f(x+h)-f(x))/h;</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><font color="#0000FF">Imprimir_Raiz( int iteracion, double raiz)</font>
{
 cout&lt;&lt;&quot;\nIteraci¢n &quot;&lt;&lt;iteracion&lt;&lt;&quot;\tRaiz = &quot;&lt;&lt;raiz;
}</pre>
<div align="center">
  <center>
  <pre><font face="Arial" color="#EA7500" size="3"><b>Funciones que implementan los metodos numéricos</b></font></pre>
  </center>
</div>
<pre><a name="//Metodo de Newton-Raphson"><font color="#800000"><b>//Método de Newton-Raphson</b></font></a><font color="#000000">
double Newton_Raphson( double x , double error=1e-6)
{
  double x_anterior;</font></pre>
<pre><font color="#000000">  int iteracion=1;</font></pre>
<pre><font color="#000000">  do
  {
   x_anterior=x;
   x=x-f(x)/fderivada(x);
  Imprimir_Raiz( iteracion++, x );
  }while( fabs(x-x_anterior)&gt;error );</font></pre>
<pre><font color="#000000">return x;</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><a name="//Metodo de la bisecci¢n"><font color="#800000"><b>//Método de la bisección</b></font></a><font color="#000000">
double Biseccion( double a, double b, double error=1e-6)
{
 double m;
 int iteracion=1;
 do
 {
  m=(a+b)/2;
  if( f(a)*f(m)&lt;0 )b=m;
  else a=m;
  Imprimir_Raiz( iteracion++, (a+b)/2 );
 }while( fabs(a-b)&gt;error );</font></pre>
<pre><font color="#000000"> return (a+b)/2;
}</font></pre>
<pre><a name="//Metodo de la falsa posici¢n"><font color="#800000"><b>//Método de la falsa posición</b></font></a><font color="#000000">
double Falsa_Posicion( double a, double b, double error=1e-6)
{
 double x1,x2,fa,fx2;
 int iteracion=1;
 x2=a;
 do
 {
  x1=x2;
  x2=a-(b-a)*f(a)/(f(b)-f(a));
  fa=f(a);
  fx2=f(x2);
  if((fa*fx2)&gt;0) a=x2; else b=x2;
  Imprimir_Raiz( iteracion++, x2 );
 }while( fabs(x2-x1)&gt;error );
}</font></pre>
<pre><a name="//Metodo de la secante"><font color="#800000"><b>//Método de la secante</b></font></a><font color="#000000">
double Secante( double x1, double x2, double error=1e-6)
{
  double fx1,fx2,x;
  int iteracion=1;
  do
  {
   fx1=f(x1);fx2=f(x2);
   x=x2-fx2*(x2-x1)/(fx2-fx1);
   x1=x2;x2=x;
  Imprimir_Raiz( iteracion++, x2 );
  }while ( fabs(x2-x1)&gt;error );
}</font></pre>
<pre><a name="//Metódo del punto fijo"><font color="#800000"><b>//Método del punto fijo</b></font></a></pre>
<pre><font color="#000000">double Punto_Fijo( double x, double error=1e-6)
{
 double x1;
 int iteracion=1;
 do
 {
  x1=x;
  x=g(x);
  Imprimir_Raiz(iteracion++,x);
 }while( fabs(x1-x)&gt;error );
}</font></pre>
<div align="left">
  <pre><font face="Arial" size="3" color="#000000"><b>METODOS NUMERICOS PARA SOLUCIONAR SISTEMAS DE ECUACIONES <a name="Ax=B ( MATRICES )">Ax=B ( MATRICES )</a></b></font></pre>
</div>
<blockquote>
  <pre><font color="#000000" face="Arial" size="3"><a href="#ALGORITMO LU POR DESCOMPOSICION GAUSSIANA">Método de Gauss - Descomposición LU</a>
<a href="#ALGORITMO DE DESCOMPOSICION LU UTILIZANDO LA ESTRATRATEGIA DEL">Método de Gauss del Pivot Máximo</a>
<a href="#ALGORITMO DE DESCOMPOSICION LU UTILIZANDO EL Método DE CHOLESKY">Método de Cholesky</a>
<a href="#ALGORITMO DE ITERACION DE GAUSS-SEIDEL">Método de Gauss-Seidel</a></font></pre>
</blockquote>
<pre><font color="#000000" face="Arial">Seudocódigo para utilizar los algoritmos anteriores:</font></pre>
<pre><font color="#000000">double x[10],W[10][10],Wo[10][10];
 int n,p[10];
 //x: contiene la solucion del sistema Ax=B
 //W: Matriz de trabajo. Inicialmente contiene A|B al final contiene a L\U
 //Wo: contiene los valores iniciales de W
 //n: numero de incognitas (orden de la matriz A)
 //p: vector de permutacion</font></pre>
<pre><font color="#800000"><b>//////////////////////////////////////////////////////////////////////
//<a name="ALGORITMO LU POR DESCOMPOSICION GAUSSIANA">ALGORITMO LU POR DESCOMPOSICION GAUSSIANA</a>
//////////////////////////////////////////////////////////////////////</b></font><font color="#000000">
void LU_Gauss(int n, double W[10][10] ,int p[10] )
{</font></pre>
<pre><font color="#000000">  int i,j,k;</font></pre>
<pre><font color="#000000"> // se inicializa p
 for(i=0;i&lt;n;i++)
  p[i]=i;</font></pre>
<pre><font color="#000000"> double m; //multiplicador</font></pre>
<pre><font color="#000000"> //Calculo de la matriz W
 for(k=0;k&lt;n-1;k++)
 {
   //se halla (el menor) j&gt;=k tal que W[p[j]][k]!=0
   for(j=k;j&lt;n;j++)
    if( W[p[j]][k]!=0 )
    {//se intercambia los contenidos de p[k] y p[j]
     m=p[k];
     p[k]=p[j];
     p[j]=m;
     break; //se encontro el j buscado
    }</font></pre>
<pre><font color="#000000">   if(j==n)//no se encontro el j buscado
   {
    cout&lt;&lt;&quot;La matriz no es inversible&quot;;
    return;
   }</font></pre>
<pre><font color="#000000">  for(i=k+1;i&lt;n;i++)
  {
   m=W[p[i]][k]=W[p[i]][k]/W[p[k]][k];</font></pre>
<pre><font color="#000000">   for(j=k+1;j&lt;=n;j++)
    W[p[i]][j]-=m*W[p[k]][j];</font></pre>
<pre><font color="#000000">  }
 }</font></pre>
<pre><font color="#000000"> //existe un cero en la diagonal
 if(W[p[n-1]][n-1]==0)
 {
  cout&lt;&lt;&quot;La matriz no es inversible&quot;;
  return;
 }</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><font color="#800000"><b>/////////////////////////////////////////////////////////////////////
//<a name="ALGORITMO DE DESCOMPOSICION LU UTILIZANDO LA ESTRATRATEGIA DEL">ALGORITMO DE DESCOMPOSICION LU UTILIZANDO LA ESTRATRATEGIA DEL</a>
//PIVOTE MAXIMO
//////////////////////////////////////////////////////////////////////</b></font><font color="#000000">
void LU_Pivot_Maximo(int n, double W[10][10] ,int p[10] )
{</font></pre>
<pre><font color="#000000"> int i,j,k;
 double m; //multiplicador
 double d[10];// d[i]= maximo( |Wij| ) 0&lt;=j&lt;n
      // d[i] = maximo valor absoluto de los elementos de la fila i de W</font></pre>
<pre><font color="#000000"> for(i=0;i&lt;n;i++)
 {
  p[i]=i;</font></pre>
<pre><font color="#000000"> //Se halla los maximos valores absolutos de cada fila y se los guarda en d[i]
 for( j=0, d[i]=0 ; j&lt;n; j++)
 {
  m=fabs(W[i][j]);
  if( m&gt;d[i] ) d[i]=m;
 }</font></pre>
<pre><font color="#000000">  if(d[i]==0)
  {
    cout&lt;&lt;&quot;La matriz no es inversible&quot;;
    return;
  }</font></pre>
<pre><font color="#000000"> }</font></pre>
<pre><font color="#000000">  //Calculo de la matriz W
 for(k=0;k&lt;n-1;k++)
 {
   //se halla (el menor) j&gt;=k tal que
   //fabs(W[p[j]][k])/d[p[j]] &gt;= fabs(W[p[i]][k])/d[p[i]]
   for(j=k;j&lt;n;j++)
   {
    for(i=k;i&lt;n;i++)
    if(  fabs(W[p[j]][k])/d[p[j]] &lt; fabs(W[p[i]][k])/d[p[i]] ) break;</font></pre>
<pre><font color="#000000">    if(i==n ) // se encontro el j buscado
    {//se intercambia los contenidos de p[k] y p[j]
     i=p[k];
     p[k]=p[j];
     p[j]=i;
     break;
    }
  }</font></pre>
<pre><font color="#000000">  for(i=k+1;i&lt;n;i++)
  {
   m=W[p[i]][k]=W[p[i]][k]/W[p[k]][k]; // se asigna el multiplicador de la fila pivote</font></pre>
<pre><font color="#000000">   for(j=k+1;j&lt;=n;j++)
      W[p[i]][j]-=m*W[p[k]][j];</font></pre>
<pre><font color="#000000">  }
 }</font></pre>
<pre><font color="#000000"> //existe un cero en la diagonal
 if(W[p[n-1]][n-1]==0)
 {
  cout&lt;&lt;&quot;La matriz no es inversible&quot;;
  return;
 }
}</font></pre>
<pre><b><font color="#800000">//////////////////////////////////////////////////////////////////////
//<a name="ALGORITMO DE DESCOMPOSICION LU UTILIZANDO EL Método DE CHOLESKY">ALGORITMO DE DESCOMPOSICION LU UTILIZANDO EL Método DE CHOLESKY</a>
//////////////////////////////////////////////////////////////////////</font></b><font color="#000000">
void LU_Cholesky( int n, double W[10][10], double x[10] )
{
 double L[10][10],Sum;
 int i,j,k;</font></pre>
<pre><font color="#000000"> for(j=0;j&lt;n;j++)
 {</font></pre>
<pre><font color="#000000">   for(Sum=0,k=0;k&lt;j;k++) Sum+=pow(L[j][k],2);</font></pre>
<pre><font color="#000000">    L[j][j]=sqrt(W[j][j]-Sum);</font></pre>
<pre><font color="#000000">   for(i=j+1;i&lt;n;i++)
   {
     for(Sum=0,k=0;k&lt;j;k++) Sum+=L[i][k]*L[j][k];</font></pre>
<pre><font color="#000000">      L[i][j]=(W[i][j]-Sum)/L[j][j];
   }
 }</font></pre>
<pre><font color="#000000">//  se asigna la matriz L a la matriz W
   for(j=0;j&lt;n;j++)
    for(i=j;i&lt;n;i++)
     if( j==i ) W[i][i]=L[i][i];
     else W[i][j]=W[j][i]=L[i][j];</font></pre>
<pre><font color="#000000">     //sustitucion hacia adelante y hacia atraz
     double b[10];
     for(k=0;k&lt;n;k++)
     {
      Sum=0.0;
       for(j=0;j&lt;k;j++) Sum+=W[k][j]*b[j];
      b[k]=W[k][n]-Sum;
     }</font></pre>
<pre><font color="#000000">     for(k=n-1;k&gt;=0;k--)
     {
      Sum=0.0;
       for(j=k+1;j&lt;n;j++) Sum+=W[k][j]*x[j];
      x[k]=(b[k]-Sum)/W[k][k];
     }

</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><font color="#800000"><b>//////////////////////////////////////////////////////////////////////
//<a name="ALGORITMO DE ITERACION DE GAUSS-SEIDEL">ALGORITMO DE ITERACION DE GAUSS-SEIDEL</a>
//////////////////////////////////////////////////////////////////////</b></font><font color="#000000">
void Gauss_Seidel(int n, double W[10][10], double x[10] )
{
 double B[10][10],C[10],x_ant[10];
 int i,j,k;</font></pre>
<pre><font color="#000000"> for(i=0;i&lt;n;i++)
 {
  for(j=0;j&lt;n;j++)
   B[i][j]= i==j ? 0 : -W[i][j]/W[i][i];</font></pre>
<pre><font color="#000000">   C[i]=W[i][n]/W[i][i];
   x[i]=0;
  }</font></pre>
<pre><font color="#000000"> double Sum,m;</font></pre>
<pre><font color="#000000"> for(m=0;m&lt;10;m++)
  for(i=0;i&lt;n;i++)
  {
   for(k=0;k&lt;n;k++)
    x_ant[k]=x[k]; //guardo el vector anterior Xm-1=Xm</font></pre>
<pre><font color="#000000">   Sum=0.0;</font></pre>
<pre><font color="#000000">   for(j=0;j&lt;i;j++)
    Sum+=B[i][j]*x[j];
   for(j=i+1;j&lt;n;j++)
    Sum+=B[i][j]*x_ant[j];</font></pre>
<pre><font color="#000000">   x[i]=Sum+C[i];
  }</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><font color="#000000">
</font><font color="#FF0000">/*/////////////////////////////////////////////////////////////////////////////
FUNCIONES PARA MOSTRAR LAS MATRICES:  x p L U
x: matriz columna con las solucion del sistema Ax=B
p: vector de permutacion del sistema
L: matriz triangular inferior
U: matriz triangular superior
Nota: PLU=A
donde P se calcula a partir de p
////////////////////////////////////////////////////////////////////////////*/</font><font color="#000000">
</font><font color="#0000FF">void Calcular_Solucion_del_Sistema_LU( int n, double W[10][10], double x[10], int p[10] )</font><font color="#000000">
{
 int i,j,k;
 //se procede a calcular la matriz x
 double Sum;  //variable que contendra la sumatoria
 for(k=n-1;k&gt;=0;k--)
 {
  for(Sum=0,j=k+1;j&lt;n;j++)
    Sum+=W[p[k]][j]*x[j];
  x[k]=(W[p[k]][n]-Sum)/W[p[k]][k];
 }</font></pre>
<pre><font color="#000000">}</font></pre>
<pre><font color="#0000FF">void Mostrar_Solucion_del_Sistema( int n, double x[10] )</font><font color="#000000">
{
   cout&lt;&lt;&quot;\nSolución al sistema Ax=B: \n&quot;;
   textcolor(LIGHTCYAN);
   for(int i=0;i&lt;n;i++)
    {
     cprintf(&quot;x[%i] = %g&quot;, i+1, x[i]);
     cout&lt;&lt;&quot;\n&quot;;
    }
}
</font></pre>
<pre><font color="#0000FF">void Ingresar_Sistema( int &amp;n, double W[10][10] )</font><font color="#000000">
{
 int i,j;</font></pre>
<pre><font color="#000000"> clrscr();
 cout&lt;&lt;&quot;\n\nIngrese el sistema Ax=B :\n\n&quot;
     &lt;&lt;&quot;Ingrese el numero de incógnitas: &quot;;
 cin&gt;&gt;n;//se ingresa orden de la matriz de la matriz A</font></pre>
<pre><font color="#000000"> cout&lt;&lt;&quot;\nIngrese los elementos de la matriz A:\n&quot;;
 textcolor(YELLOW);
 for(i=0;i&lt;n;i++)	//se ingresa los elementos de la matriz A
 {
   for(j=0;j&lt;n;j++)
   {
    cprintf(&quot;A[%i,%i] = &quot;,i,j);
    cin&gt;&gt;W[i][j];
   }
  cout&lt;&lt;&quot;\n&quot;;
 }</font></pre>
<pre><font color="#000000"> cout&lt;&lt;&quot;\nIngrese los elementos de la matriz B:\n&quot;;
 textcolor(LIGHTGREEN);
 for(i=0;i&lt;n;i++)	//se ingresa los elementos de la matriz B
 {
  cprintf(&quot;B[%i] = &quot;,i);
  cin&gt;&gt;W[i][n];
 }
}
</font></pre>

</body>

</html>

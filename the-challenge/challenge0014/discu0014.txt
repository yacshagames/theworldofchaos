Estas son unas discusiones que surgieron mediante el desarrollo del Reto0014:


Message:
   Date: Mon, 5 Mar 2001 16:39:58 -0500
   From: "José Luis De la Cruz Lázaro" <jcruz@ec-red.com>
Subject: [El Reto] 0014 - Final

Este mensaje es solo para Nyder:

 Solo quiero que me expliques una cosa, que dabas por sentada, es cierto que
en algún momento había que intercambiar los valores de las variables a y b
sin variable auxiliar, para esto tu escogiste el algoritmo de las cubetas
 que fue explicado en esta lista hace algún tiempo ), a saber:

a = a+b; //¿acá hay un error?
b = a-b;
a = a-b;

Como sabemos si a+b puede contener valores superiores al máximo permitido
por el tipo int, por lo tanto se pierde 1 bit al hacer dicha suma y asignar
este valor a "a", sin embargo al hacer b = a-b, parece como si no hubiera
sucedido dicho efecto, es decir,  b contiene el valor de a, y por ende el
programa se ejecuta satisfactoriamente. ¿Como explicas esto?

En el próximo mensaje envío la solución JUEZ.

De todas formas por ser el ganador de este reto, ahora te toca proponer el
siguiente Reto ( 0015 ). Espero tu reto en la lista.

Un saludo.

          o  o José Luis De la Cruz Lázaro o   220KV of Chaos
     o       o  Visit my homepage:          o      o
   o    o o    o EL MUNDO DEL CAOS            o   o o
  o   o  o     o  www.geocities.com/joseluisdl  o    o  o
  o    o     o     ICQ: 46906401                      o  o
   o     o o     Chaos = Chaos & math ? C++ : ++C;        o
     o                                                     o
        o  o  o o o  FRACTALS UNLIMITED ooo o  o  o  o  o   o
                    o  o   o   o   o   o
     o               o   o   o   o   o
   o   o      o
 o      o   o  o  o  o  o o oooo Universidad Nacional de Ingeniería
          o     o                 Facultad de Ingeniería Eléctrica y
                                             Electrónica
                                 O  O  o ooo Lima - Perú ooo o o O  O


Respuesta :

Message:
   Date: Tue, 6 Mar 2001 00:16:00 -0600
   From: Nyder Menéndez <nyder2000@yahoo.es>
Subject: Re:  [El Reto] 0014 - Final --->Respuesta...

Saludos...
(Aunque parezca redundancia...  :-)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
>Solo quiero que me expliques una cosa, que dabas por sentada, es
>cierto que en algún momento había que intercambiar los valores de
>las variables a y b sin variable auxiliar, para esto tu escogiste
>el algoritmo de las cubetas que fue explicado en esta lista hace
>algún tiempo ), a saber:

>a = a+b; //¿acá hay un error?
>b = a-b;
>a = a-b;

>Como sabemos si a+b puede contener valores superiores al máximo
>permitido por el tipo int, por lo tanto se pierde 1 bit al hacer
>dicha suma y asignar este valor a "a", sin embargo al hacer b = a-b,
>parece como si no hubiera sucedido dicho efecto, es decir, b contiene
>el valor de a, y por ende el programa se ejecuta satisfactoriamente.
>¿Como explicas esto?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Bien..
. no se si entendí bien la pregunta...
pero vamos a tratar de explicarlo...

(voy a tratar de explicarlo con números...
o sea... matemáticamente...
luego espero que me lo expliques...
en bits... que de eso creo que entiendes...
mejor que yo...  :-)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Supongamos, (para hacerlo más sencillo)...
que los números enteros tuviesen un rango de          -21 a 20

y demos dos números arbitrarios...                     15 y 8

que están dentro del rango de -21 a 20...
pero cuya suma... cae fuera de este rango...

(como recordaremos el C no controla este tipo...
de situaciones... ...esto corresponde al programador...
o sea... nosotros...  :-)

Cuando el programa "suma" ambos valores... y se "topa"...
con el valor máximo permitido...
entonces el programa "hace" lo siguiente...

(según puedo comprender...)


int a,b;
a=15;
b=8;

a=a+b;

//  a=   15 + (......................8........................)
//  a=   15... +1    +1    +1    +1    +1     +1     +1     +1
//             16... 17... 18... 19... 20... -21... -20... -19
//
//  luego...
//  a sería igual a -19

b=a-b;

//  b=   -19 - (.....................8........................)
//  b=   -19...  -1     -1    -1    -1    -1    -1    -1    -1
//              -20... -21... 20... 19... 18... 17... 16... 15
//
//  luego...
//  b sería igual a 15... que era el valor original de "a"...
//  lo cual corrige...el "error" provocado por el "desbordamiento"...
//  si se le puede llamar así...

//  y por supuesto... con...

a=a-b;

//  ocurriría lo mismo... solo que sería... un poquito más largo...
//  y si lo deseas lo puedes comprobar...
//  quedando finalmente "a" con un valor de 8...
//  que era el valor anterior de b...

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Esta sería "mi explicación"... dentro de la lógica...
como la veo...

Ahora... me gustaría ver... la explicación... con los bits...

:-)

Por cierto... aún no he probado la solución...
pero voy a analizarla en unos momentos...
para aprender como es eso de los XOR...
(para mí es material nuevo... aunque exista hace mucho... :-)

pero me encanta aprender...
tener nuevas herramientas para...
aplicarlas en las lógicas...
que a uno le toca desarrollar...

nyder2000@yahoo.es

Respuesta:

Message:
   Date: Tue, 6 Mar 2001 10:31:31 -0500
   From: "José Luis De la Cruz Lázaro" <jcruz@ec-red.com>
Subject: RE:  [El Reto] 0014  - Respuesta a Nyder

Hola Nyder

>    From: Nyder Menéndez <nyder2000@yahoo.es>
>
> Esta sería "mi explicación"... dentro de la lógica...
> como la veo...

Tu explicación fue excelente :-) , muy buena investigación sobre el
tratamiento interno de los números enteros.

> Ahora... me gustaría ver... la explicación... con los bits...
>
> :-)

Ya que lo pides, daré la respuesta pero desde el punto de vista binario:

En primer lugar esto no solo se cumple en C, se cumple en cualquier sistema
electrónico digital, los procesadores están diseñados para trabajar con esta
convención y por ende el software debe adaptarse a esta situación.

Para hacer la explicación más fácil, supongamos que un tipo "int" tenga 5
bits, entonces tenemos, que el bit de mayor peso será el bit de signo ( 0 =
"+" , 1 = "-" ), esto quiere decir que el número entero propiamente dicho,
solo sería representado con 15 bits.

Por ejemplo el número 13 se define binariamente como:

 0 1101
 | \  /
 | número
 +--- signo positivo

Pero para -13 se definirá como sigue:

 1 0011
 | \  /
 | número
 +--- signo negativo

Se observa que: número = 0011 = 3 = 16 - 13 = 2^4 - 13

Es por esto que a esta convención se la llama "Complemento a 2", porque el
número propio negativo , resulta ser el complemento aritmético con respecto
a la potencia de 2 inmediata superior.

Esto explica porque el rango de los números enteros para este caso será
de -16 a 15 y no de -15 a 16.

Después de esta pequeña introducción a la representación entera binaria,
podré explicar porque no sucede el aparente error de desborde en la
operación: a = (a + b) - b;

Suponiendo a=15 y b=3 del tipo "int" ( 5 bits ) definido anteriormente,
entonces:

Al aplicar la suma binaria( es como sumar en base 10, pero el acarreo será
un binario ):

15 = 01111
 3 = 00011 +
     -------
     10010 = ¿18?

Con lo que vemos que la suma si funciona, porque si estuviéramos utilizando
un tipo "int" mayor a 5 bits, 10010 = 18 = 15 + 3. Pero no es así, ya que de
lo que explicamos anteriormente 10010 = -14.

Luego al aplicar la diferencia binaria:

-14 = 10010
  3 = 00011 -
      -------
      01111 = 15

Con lo que se observa que todo vuelve a la normalidad otra vez.

Como conclusión, se puede decir que los números negativos en un tipo "int",
representan la continuación binaria de los números positivos, comportándose
internamente como un "unsigned int".

Espero que esta pequeña explicación haya saciado tu inquietud.

> Por cierto... aún no he probado la solución...
> pero voy a analizarla en unos momentos...
> para aprender como es eso de los XOR...
> (para mí es material nuevo... aunque exista hace mucho... :-)

El XOR tiene muchas aplicaciones al software y hardware, y su principal
importancia radica en que es un operador directo e inverso a la vez, por
ejemplo:

 (7^15)^7 = 15  que es análogo a: (7+15)-7 =15

Esta peculiaridad le otorga una mayor velocidad a los cálculos numéricos que
hace el procesador, es por eso que cuando se quiere utilizar máscaras se
prefiere utilizar el XOR, en lugar de operaciones aritméticas que demoran
más tiempo y además producen desbordes.

Por ejemplo una máscara que es bien conocida, está presente cuando mueves
una ventana en MS Windows, cierto que al desplazar la ventana, esta aparece
representada solo por su marco, que es un simple rectángulo, si te fijas
bien verás que los píxeles del rectángulo toman el color inverso del lugar
donde estén, es decir, utilizan como mascara el color de la pantalla. Este
es un viejo truco que sirve para visualizar siempre dicho rectángulo
independientemente del color de su fondo. Y esto se hace con un simple XOR:

Donde "mascara" es un color "control", que va a controlar que la dispersión
del tono de color, no varíe mucho con respecto a "mascara". Para el ejemplo
mascara puede ser el color gris.

color = mascara^color //se halla el color del píxel del rectángulo
//pintar el "color" del píxel
color = mascara^color //se recupera el color de la pantalla para pintarlo
después que se mueve el rectángulo de su posición.

Un saludo... Suerte.

          o  o José Luis De la Cruz Lázaro o   220KV of Chaos
     o       o  Visit my homepage:          o      o
   o    o o    o EL MUNDO DEL CAOS            o   o o
  o   o  o     o http://www.geocities.com/joseluisdl o  o
  o    o     o     ICQ: 46906401                 o    o  o
   o     o o     Chaos = Chaos & math ? C++ : ++C;        o
     o                                                     o
        o  o  o o o  FRACTALS UNLIMITED ooo o  o  o  o  o   o
                    o  o   o   o   o   o
     o               o   o   o   o   o
   o   o      o
 o      o   o  o  o  o  o o oooo Universidad Nacional de Ingeniería
          o     o                 Facultad de Ingeniería Eléctrica y
                                             Electrónica
                                 O  O  o ooo Lima - Perú ooo o o O  O




